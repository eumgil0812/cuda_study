---
title: "(8) BootInfo and ACPI RSDP"
datePublished: Thu Sep 25 2025 12:00:53 GMT+0000 (Coordinated Universal Time)
cuid: cmfzd3d4s000602k89y496xc9
slug: 8-bootinfo-and-acpi-rsdp
tags: acpi

---

## 1\. Why is a BootInfo Structure Needed?

A bootloader ultimately needs to **pass environment information to the operating system kernel**.  
UEFI provides a large structure (`EFI_SYSTEM_TABLE`), but:

* For a self-written kernel, consuming the full UEFI table is **heavy and overly complex**.
    
* Interfaces differ across OS implementations, which reduces portability.
    

Therefore, most bootloaders define a **fixed interface** to hand over to the kernel.  
This is often represented as a structure like `BootInfo`.

👉 **Summary:** BootInfo ensures the kernel is not tightly coupled to the bootloader; as long as a fixed contract exists, the kernel can boot independently.

---

## 2\. Typical Contents of BootInfo

A `BootInfo` structure usually includes:

1. **Memory map information**
    
    * Obtained via UEFI `GetMemoryMap()`.
        
    * Contains type (usable, reserved, ACPI, MMIO, etc.), base address, and length.
        
2. **ACPI RSDP address**
    
    * Root System Description Pointer of the Advanced Configuration and Power Interface.
        
    * Allows the kernel to parse ACPI tables (e.g., FADT, MADT) to obtain CPU, interrupt, and power management data.
        
3. **Framebuffer information (if graphics mode is enabled)**
    
    * Resolution, pitch, pixel format, and framebuffer address.
        
4. **Boot mode/options**
    
    * Indicates the boot device, debug flags, etc.
        
5. **Bootloader version/signature**
    
    * Enables the kernel to verify: *“This BootInfo is in a format I understand.”*
        

---

## 3\. Why Passing ACPI RSDP Matters

### 3.1 What is RSDP?

* The **Root System Description Pointer** is a small structure in memory.
    
* It contains the physical address of the **RSDT (Root System Description Table)** or the extended **XSDT**.
    
* RSDP itself holds little information; its role is to point the way to the full ACPI table set.
    

### 3.2 Following the RSDP

* **RSDT/XSDT** is essentially a pointer list to other ACPI tables.
    
* Common tables include:
    
    * **FADT (Fixed ACPI Description Table)** → Power management (power button, sleep states).
        
    * **MADT (Multiple APIC Description Table)** → CPU count, Local APIC, IOAPIC configuration.
        
    * **HPET (High Precision Event Timer)** → High-resolution timers.
        
    * **DSDT (Differentiated System Description Table)** → AML bytecode for device initialization.
        

Thus, the kernel does not extract system data from the RSDP itself, but rather by traversing:  
👉 **RSDP → RSDT/XSDT → individual ACPI tables.**

### 3.3 Why BootInfo Only Needs to Pass RSDP

* UEFI’s `EFI_SYSTEM_TABLE` contains the RSDP pointer, but the kernel doesn’t need to know the UEFI API.
    
* If BootInfo contains just the `rsdp_addr`, the kernel can independently walk through RSDT/XSDT and discover FADT, MADT, DSDT, etc.
    
* Because ACPI parsing is standardized, a kernel can fully initialize the system with nothing more than this pointer.
    

---

## 4\. Example BootInfo Structure in C

```c
typedef struct {
    uint64_t memory_map;      // Memory map base address
    uint64_t memory_map_size; // Total size
    uint64_t memory_map_desc_size;
    uint64_t rsdp;            // ACPI RSDP address
    uint64_t framebuffer_addr;
    uint32_t framebuffer_width;
    uint32_t framebuffer_height;
    uint32_t framebuffer_pitch;
    uint32_t framebuffer_bpp; // Bits per pixel
    uint32_t boot_flags;      // Debug mode, etc.
    char     bootloader_name[32];
} BootInfo;
```

* **Bootloader:** fills this structure and passes a pointer to the kernel entry point.
    
* **Kernel:** simply receives `BootInfo*` and interprets it.
    

---

## 5\. Path Toward a “Standardized” Bootloader

* A bootloader that only loads an ELF binary → **experimental**.
    
* A bootloader that provides a structured BootInfo interface → **safe/standard**.
    
* Most real OSes use a BootInfo/Multiboot-like interface.
    
    * Example: **Multiboot2 specification** used by GRUB.
        

---

## 6\. Diagram of ACPI Discovery

```cpp
[BootInfo.rsdp] ────▶ [RSDP]
                       │
                       ▼
                  [RSDT / XSDT]
                       │
     ┌──────────────┬──────────────┬───────────────┐
     ▼              ▼              ▼
 [FADT]         [MADT]          [DSDT] ...
 Power Mgmt     CPU/APIC Info   AML-based Device Init
```

---

## ✅ Final Takeaways

* It’s not that *“there is no ACPI table”* — rather, the **RSDP points to the root of the ACPI table hierarchy**.
    
* BootInfo only needs to carry the **RSDP pointer**.
    
* The kernel can then traverse RSDT/XSDT → FADT, MADT, DSDT, etc., to learn about CPU topology, power management, and device configuration, and bring up the system.