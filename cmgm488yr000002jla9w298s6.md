---
title: "üñ•Ô∏è [OS Scheduler Practice ‚ë•] Multilevel Queue"
datePublished: Sat Oct 11 2025 10:11:26 GMT+0000 (Coordinated Universal Time)
cuid: cmgm488yr000002jla9w298s6
slug: os-scheduler-practice-multilevel-queue
tags: queue, scheduling

---

# Multilevel Queue ‚Äî A Taste of Real OS Scheduling

[https://github.com/eumgil0812/os/blob/main/scheduler/multi\_que.c](https://github.com/eumgil0812/os/blob/main/scheduler/multi_que.c)

## üß† 1. What is Multilevel Queue Scheduling?

In real operating systems, **a single scheduling algorithm** is often not enough.  
Different processes have different needs:

* System processes ‚Üí need fast response
    
* Interactive processes ‚Üí need short, frequent time slices
    
* Background jobs ‚Üí can wait longer
    

üëâ The solution: **Multilevel queue scheduling**

* Use **multiple ready queues**, each with **different scheduling algorithms**.
    
* Assign each queue a **fixed priority level**.
    
* Always schedule from the highest-priority queue first.
    

üìå Example configuration:

* Queue 0 (highest priority): RR
    
* Queue 1: SJF
    
* Queue 2 (lowest priority): FCFS
    

---

## üèóÔ∏è 2. Key Characteristics

| Item | Description |
| --- | --- |
| Number of ready queues | Multiple |
| Priority | Fixed per queue (0 &gt; 1 &gt; 2 ...) |
| Algorithm | Each queue uses a different scheduler |
| Preemption | Possible (higher queue preempts lower) |
| Advantage | Flexible handling of different workloads |
| Drawback | Starvation in lower-priority queues |

---

## üßÆ 3. Example Scenario

| PID | AT | BT | Queue | Algorithm |
| --- | --- | --- | --- | --- |
| P1 | 0 | 4 | 0 | RR |
| P2 | 1 | 5 | 1 | SJF |
| P3 | 2 | 2 | 0 | RR |
| P4 | 4 | 3 | 2 | FCFS |

* RR time quantum: 2
    
* Queue priority: 0 ‚Üí 1 ‚Üí 2
    

---

## üíª 4. C Implementation (Basic)

```c
#include <stdio.h>

typedef struct {
    char pid[5];
    int arrival;
    int burst;
    int queue;
    int remaining;
    int finish;
    int waiting;
    int turnaround;
} Process;

int main() {
    int n;
    printf("Enter number of processes: ");
    scanf("%d", &n);

    Process p[n];
    for (int i = 0; i < n; i++) {
        sprintf(p[i].pid, "P%d", i+1);
        printf("Arrival time of %s: ", p[i].pid);
        scanf("%d", &p[i].arrival);
        printf("Burst time of %s: ", p[i].pid);
        scanf("%d", &p[i].burst);
        printf("Queue of %s (0=RR, 1=SJF, 2=FCFS): ", p[i].pid);
        scanf("%d", &p[i].queue);
        p[i].remaining = p[i].burst;
    }

    int tq = 2; // RR time quantum
    int completed = 0, current_time = 0;
    int gantt[1000], gantt_time[1000], g_index = 0;

    while (completed < n) {
        int idx = -1;
        int highestQ = 999;

        // 1. Find the highest-priority queue with ready processes
        for (int i = 0; i < n; i++) {
            if (p[i].arrival <= current_time && p[i].remaining > 0) {
                if (p[i].queue < highestQ) highestQ = p[i].queue;
            }
        }

        // 2. Choose a process based on the queue's algorithm
        if (highestQ != 999) {
            if (highestQ == 0) { // RR
                for (int i = 0; i < n; i++) {
                    if (p[i].arrival <= current_time && p[i].remaining > 0 && p[i].queue == 0) {
                        idx = i; break;
                    }
                }
            } else if (highestQ == 1) { // SJF
                int minBT = 1e9;
                for (int i = 0; i < n; i++) {
                    if (p[i].arrival <= current_time && p[i].remaining > 0 && p[i].queue == 1) {
                        if (p[i].remaining < minBT) {
                            minBT = p[i].remaining;
                            idx = i;
                        }
                    }
                }
            } else if (highestQ == 2) { // FCFS
                int minAT = 1e9;
                for (int i = 0; i < n; i++) {
                    if (p[i].arrival <= current_time && p[i].remaining > 0 && p[i].queue == 2) {
                        if (p[i].arrival < minAT) {
                            minAT = p[i].arrival;
                            idx = i;
                        }
                    }
                }
            }
        }

        gantt_time[g_index] = current_time;
        gantt[g_index++] = idx;

        if (idx == -1) {
            current_time++;
            continue;
        }

        if (p[idx].queue == 0) { // RR
            int exec = (p[idx].remaining >= tq) ? tq : p[idx].remaining;
            p[idx].remaining -= exec;
            current_time += exec;
        } else { // SJF or FCFS
            current_time += p[idx].remaining;
            p[idx].remaining = 0;
        }

        if (p[idx].remaining == 0) {
            p[idx].finish = current_time;
            p[idx].turnaround = p[idx].finish - p[idx].arrival;
            p[idx].waiting = p[idx].turnaround - p[idx].burst;
            completed++;
        }
    }

    gantt_time[g_index] = current_time;

    // Gantt Chart
    printf("\n[Multilevel Queue Scheduling] Gantt Chart:\n");
    int last = -2;
    for (int i = 0; i < g_index; i++) {
        if (gantt[i] != last) {
            if (gantt[i] == -1) printf("| Idle ");
            else printf("| %s ", p[gantt[i]].pid);
            last = gantt[i];
        }
    }
    printf("|\n0");
    last = -2;
    for (int i = 0; i < g_index; i++) {
        if (gantt[i] != last) {
            printf("%5d", gantt_time[i]);
            last = gantt[i];
        }
    }
    printf("%5d\n", current_time);

    // Table
    float total_wt = 0, total_tat = 0;
    printf("\n%-5s %-5s %-5s %-5s %-5s %-5s %-5s\n","PID","AT","BT","Q","WT","TAT","FT");
    for (int i = 0; i < n; i++) {
        total_wt += p[i].waiting;
        total_tat += p[i].turnaround;
        printf("%-5s %-5d %-5d %-5d %-5d %-5d %-5d\n",
               p[i].pid,p[i].arrival,p[i].burst,p[i].queue,
               p[i].waiting,p[i].turnaround,p[i].finish);
    }
    printf("\nAverage WT: %.2f\nAverage TAT: %.2f\n", total_wt/n, total_tat/n);

    return 0;
}
```

üëâ Queue 0 (highest) is executed first, followed by Queue 1 (SJF), then Queue 2 (FCFS).

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1760177067101/143f39a9-4238-483b-9bec-a408e38e3bdb.png align="center")

---

## üß≠ 6. Summary

| Item | Description |
| --- | --- |
| Algorithm mix | RR + SJF + FCFS |
| Priority | Queue 0 &gt; Queue 1 &gt; Queue 2 |
| Advantage | Flexible handling of different workloads |
| Disadvantage | Starvation possible in lower-priority queues |
| Solution | Use **Aging** or dynamic priority |

‚úÖ Multilevel Queue Scheduling gives you a **taste of how real OS schedulers work**.

---

## üöÄ Further Extensions

* Add **aging** to prevent starvation.
    
* Upgrade to **Multilevel feedback queue scheduling (MLFQ)**.
    
* Add visualization tools for better timeline analysis.
    

üìå **One-line takeaway:**

> *‚ÄúMultilevel Queue Scheduling combines multiple scheduling algorithms into priority layers, just like real operating systems.‚Äù*