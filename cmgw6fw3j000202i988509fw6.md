---
title: "(9)Kernel Log"
datePublished: Sat Oct 18 2025 11:11:04 GMT+0000 (Coordinated Universal Time)
cuid: cmgw6fw3j000202i988509fw6
slug: 9kernel-log

---

Last time, due to the UD exception issue, it took a long time to print logs on the screen.  
This time, to make future development smoother, I implemented a logging feature inside the kernel that automatically scrolls the screen when the log output exceeds the visible area.

---

## 1.Getting the Font

In an operating system, simply drawing pixels on the screen isnâ€™t enough to display meaningful text.  
Especially during the early kernel initialization stage, thereâ€™s no GUI or high-level graphics library available.  
All rendering must be done manually by **writing pixels directly to the framebuffer**.

However, drawing every character pixel by pixel is inefficient and cumbersome.  
Thatâ€™s why most operating systems use **bitmap fonts**.

A bitmap font stores each character as a predefined pixel pattern.  
For example, the letter `A` can be represented as an 8Ã—16 pixel bitmap.  
By copying this bitmap directly to the framebuffer, we can display the character on the screen.  
This allows text rendering to follow a simple and fast process:

Character â†’ Font data â†’ Pixels on the screen

[https://gitlab-beta.engr.illinois.edu/ejclark2/linux/-/blob/4bedea94545165364618d403d03b61d797acba0b/drivers/video/console/font\_8x16.c](https://gitlab-beta.engr.illinois.edu/ejclark2/linux/-/blob/4bedea94545165364618d403d03b61d797acba0b/drivers/video/console/font_8x16.c)

## 2\. fb.c â€” Framebuffer Console Driver

`fb.c` is the **low-level text rendering module** of my OS project.  
It directly writes pixels to the framebuffer memory, allowing the kernel to display characters and logs without relying on any external graphics library or BIOS text mode.

In modern boot environments like UEFI, we canâ€™t use the legacy VGA text mode anymore.  
Instead, we receive a pointer to the **framebuffer base address** during boot, and everything must be rendered manually using pixels.

```c
//fb.h
#ifndef FB_H
#define FB_H

#include <stdint.h>

typedef struct {
    void* FrameBufferBase;
    unsigned int HorizontalResolution;
    unsigned int VerticalResolution;
    unsigned int PixelsPerScanLine;
    uint8_t verified;
    uint8_t kernel_hash[32];
} BootInfo;


void putpixel(BootInfo* bi, int x, int y, uint32_t color);

void draw_char(BootInfo* bi, int x, int y, char c, uint32_t fg, uint32_t bg);
void fb_scroll(BootInfo* bi);
void kputs_fb(BootInfo* bi, const char* s);

#endif
```

This file implements basic but essential text rendering functions:

* `putpixel()` â€” Draws a single pixel on the framebuffer at a specific coordinate.  
    This is the most fundamental primitive on top of which everything else is built.
    
* `draw_char()` â€” Renders a character by reading its bitmap data (e.g. VGA 8Ã—16 font) and drawing each pixel.
    
* `kputs_fb()` â€” Prints a string on the screen, handling cursor movement and line wrapping.
    
* `fb_scroll()` â€” Implements scrolling when the text reaches the bottom of the screen by moving the framebuffer contents upward.
    
* `fb_newline()` â€” Moves the cursor to the next line and triggers scrolling if needed.
    

Together, these functions make up a **minimal text console** that runs fully inside the kernel.  
This console allows me to print kernel logs, debug information, and eventually build interactive shell features.

## 3\. `font.c` â€” String Rendering Layer

```c
//font.h
#ifndef FONT_H
#define FONT_H

#include <stdint.h>
#include "fb.h"           // BootInfo 

#define FONTDATAMAX (256 * 16)

struct font_desc {
    const char* name;
    unsigned width, height, count;
    const void* data;
};

extern unsigned char fontdata_8x16[FONTDATAMAX];
extern struct font_desc font_vga_8x16;


void draw_string(BootInfo* bi, int x, int y, const char* s, uint32_t fg, uint32_t bg);

#endif
```

In low-level OS development, everything that appears on the screen must be rendered manually.  
While `draw_char()` in `fb.c` is responsible for rendering a **single character**, itâ€™s not very convenient to print long strings this way.

Thatâ€™s where `draw_string()` comes in.  
This simple helper function makes it possible to render an entire string at once by drawing each character sequentially and advancing the X position accordingly.

## 4\. `kprintf.c` â€” Minimal Kernel Printf Implementation

```c
//kprintf.h

#ifndef KPRINTF_H
#define KPRINTF_H

#include "fb.h"  // Required for BootInfo structure

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Minimal kernel printf function (Framebuffer console output)
 *
 * Supported format specifiers:
 *   - %d : Decimal integer (supports negative values)
 *   - %x : Hexadecimal integer
 *   - %s : String
 *   - %c : Character
 *   - %% : Print literal '%'
 *
 * @param bi   Pointer to BootInfo (framebuffer information)
 * @param fmt  Format string
 * @param ...  Variadic arguments
 */
void kprintf(BootInfo* bi, const char* fmt, ...);

#ifdef __cplusplus
}
#endif

#endif /* KPRINTF_H */
```

In a bare-metal OS environment, thereâ€™s no `stdio.h`, no `printf`, and no standard C library.  
That means **if you want formatted output** in your kernel, you have to build it yourself.

`kprintf.c` is my minimal implementation of a `printf`\-like function for the kernel.  
It works directly with the framebuffer console to display formatted text during boot and runtime.

## 4\. Makefile

```c
#  Toolchain configuration
CC      = x86_64-elf-gcc
LD      = x86_64-elf-ld
CFLAGS  = -ffreestanding -fno-pie -fno-pic -nostdlib -I.
LDFLAGS = -T kernel.ld -nostdlib -no-pie

#  object files
OBJS = kernel.o serial.o fb.o font.o font_8x16.o kprintf.o string.o


TARGET  = kernel.elf
SIGNKEY = priv.pem
SIGNOUT = kernel.sig

# Default build: clean â†’ build â†’ sign
all: clean $(TARGET) sign

# Compile .c files into .o object files
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# Link all object files into the final ELF binary
$(TARGET): $(OBJS)
	$(LD) $(LDFLAGS) $(OBJS) -o $(TARGET)
	@echo "âœ… Build complete: $(TARGET)"

# Sign ELF binary with private key
sign:
	openssl dgst -sha256 -sign $(SIGNKEY) -out $(SIGNOUT) $(TARGET)
	@echo "ðŸ” Signed kernel: $(SIGNOUT)"

# Clean up build artifacts
clean:
	rm -f $(OBJS) $(TARGET) $(SIGNOUT)
	@echo "ðŸ§¹ Clean done"

.PHONY: all clean sign
```

```c
Kernel
â”œâ”€â”€ Makefile
â”œâ”€â”€ fb.c
â”œâ”€â”€ fb.h
â”œâ”€â”€ font.c
â”œâ”€â”€ font.h
â”œâ”€â”€ font_8x16.c
â”œâ”€â”€ font_8x16.h
â”œâ”€â”€ kernel.c
â”œâ”€â”€ kprintf.c
â”œâ”€â”€ kprintf.h
â”œâ”€â”€ serial.c
â”œâ”€â”€ serial.h
â”œâ”€â”€ string.c
â”œâ”€â”€ string.h
â”œâ”€â”€ priv.pem
â””â”€â”€ pubkey.der
```

## Github

ðŸŽ¥ Demo Video: [Watch on Naver Blog](https://blog.naver.com/eumgil97/224045705787)

ðŸ“‚ Source Code: [GitHub Repository](https://github.com/eumgil0812/OwnOS.git)

Commit: `git checkout d7ee86`