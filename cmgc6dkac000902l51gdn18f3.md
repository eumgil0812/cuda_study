---
title: "Building a Full Virtual Network Lab with tinet and Docker"
datePublished: Sat Oct 04 2025 11:13:52 GMT+0000 (Coordinated Universal Time)
cuid: cmgc6dkac000902l51gdn18f3
slug: building-a-full-virtual-network-lab-with-tinet-and-docker
tags: tinet

---

Networking is not just theory — you can build an entire lab environment on your laptop.  
In this post, we’ll create a **realistic virtual network topology** using [`tinet`](https://github.com/tinynetwork/tinet), a lightweight network testbed framework that combines **Docker**, **Linux network namespaces**, and **veth** interfaces.

This guide walks you through everything — from setup to cleanup — so you can reproduce a real router-client topology and run experiments with FRRouting.

---

## 🧱 1. Environment Setup

Before diving in, make sure you’re using:

* **Ubuntu 22.04+** (Desktop or Server)
    
* **Docker** installed and working
    
* **sudo privileges**
    

### Install required packages

```bash
sudo apt update
sudo apt install -y docker.io git make iproute2 bridge-utils net-tools
sudo systemctl enable docker
sudo systemctl start docker
```

---

## ⚙️ 2. Installing `tinet`

`tinet` is written in Go, but you don’t need Go locally — we’ll build it using Docker.

```bash
git clone https://github.com/tinynetwork/tinet tinet
cd tinet
docker run --rm -it -v $PWD:/v -w /v golang:1.12 go build
sudo mv tinet /usr/local/bin/
tinet --version
```

Expected output:

```bash
tinet version 0.0.1
```

---

## 🌐 3. Understanding the Example Topology

`tinet` provides built-in examples under `examples/simple/`.  
We’ll use the `topo2` example, which defines a **two-router, four-client** topology:

```bash
cd examples/simple/topo2
ls
# spec.yaml
```

### Network Structure

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1759573340282/b7d3807d-f0d9-4125-9a04-3e3cbab7c5de.png align="center")

You can visualize the topology as an image using **Graphviz**.

```bash
sudo apt install graphviz -y        # Install Graphviz (for rendering)
tinet img -c spec.yaml | dot -Tpng > topo.png   # Generate PNG from spec.yaml
```

* **R1, R2** → Routers (running FRRouting)
    
* **C1~C4** → Client containers
    
* **veth pairs** connect clients to routers
    

---

## 🌐 4. Make Up\_with\_ip.sh

At first, I tried to create the [`up.sh`](http://up.sh) directly from the `spec.yaml` file.

```bash
tinet up -c spec.yaml > up.sh
```

Because the [`up.sh`](http://up.sh) generated by tinet doesn’t assign IP addresses, deletes containers after they stop, and doesn’t preserve network namespace links,  
I rewrote it myself into a fully **persistent + auto IP setup** version.

### 🧠 **Revised** [**up.sh**](http://up.sh) **(Persistent + Auto IP Setup Version)**

```bash
#!/bin/bash
# ============================================
# TINET persistent + auto IP setup version
# Author: Skylar
# ============================================

# 1️⃣ Create containers (persistent: without --rm)
for node in R1 R2 C1 C2 C3 C4; do
  echo "🚀 Creating container: $node"
  docker run -td --net none --name $node --privileged --hostname $node \
    -v /tmp/tinet:/tinet slankdev/frr > /dev/null

  # Register container's network namespace
  mkdir -p /var/run/netns > /dev/null
  PID=$(docker inspect $node --format '{{.State.Pid}}')
  ln -sf /proc/$PID/ns/net /var/run/netns/$node
done

# 2️⃣ Create veth links between routers and clients
echo "🔗 Creating veth connections..."
ip link add net0 netns R1 type veth peer name net0 netns R2
ip link add net1 netns R1 type veth peer name net0 netns C1
ip link add net2 netns R1 type veth peer name net0 netns C2
ip link add net1 netns R2 type veth peer name net0 netns C3
ip link add net2 netns R2 type veth peer name net0 netns C4

# 3️⃣ Bring interfaces up (loopback + veth)
echo "⬆️  Bringing interfaces up..."
for ns in R1 R2 C1 C2 C3 C4; do
  ip netns exec $ns ip link set lo up
done

for link in \
  "R1 net0" "R1 net1" "R1 net2" \
  "R2 net0" "R2 net1" "R2 net2" \
  "C1 net0" "C2 net0" "C3 net0" "C4 net0"
do
  set -- $link
  ip netns exec $1 ip link set $2 up
done

# 4️⃣ Assign static IP addresses
echo "🌐 Assigning IP addresses..."
ip netns exec R1 ip addr add 10.0.0.1/24 dev net0
ip netns exec R2 ip addr add 10.0.0.2/24 dev net0

ip netns exec R1 ip addr add 10.0.1.1/24 dev net1
ip netns exec C1 ip addr add 10.0.1.2/24 dev net0

ip netns exec R1 ip addr add 10.0.2.1/24 dev net2
ip netns exec C2 ip addr add 10.0.2.2/24 dev net0

ip netns exec R2 ip addr add 10.0.3.1/24 dev net1
ip netns exec C3 ip addr add 10.0.3.2/24 dev net0

ip netns exec R2 ip addr add 10.0.4.1/24 dev net2
ip netns exec C4 ip addr add 10.0.4.2/24 dev net0

# 5️⃣ Verification
echo
echo "✅ Network up and IPs assigned successfully!"
echo
docker ps --format "table {{.Names}}\t{{.Status}}"
echo
ip netns list
echo
echo "🔎 Example ping test (C1 → R1)"
ip netns exec C1 ping -c 2 10.0.1.1 || echo "⚠️ Ping failed!"
```

---

## 📋 **What Changed Compared to Original tinet** [**up.sh**](http://up.sh)

| Problem in tinet [up.sh](http://up.sh) | How This Script Fixes It |
| --- | --- |
| ❌ No IP assigned | ✅ Adds `ip addr add` commands for each veth pair |
| ❌ Containers deleted after `docker stop` | ✅ Removed `--rm` → containers persist |
| ❌ No `/var/run/netns` links | ✅ Automatically re-creates namespace links via `ln -sf` |
| ❌ Hard to debug | ✅ Added clear logging + ping test section |

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1759575704018/8ffb5797-11c7-4e76-be4e-01ee6634545c.png align="center")

You shouldn’t run `up_with_`[`ip.sh`](http://ip.sh) twice because it **creates everything from scratch** —  
containers, virtual links, and namespaces.

If you run it again:

* Docker says **“container name already in use”**,
    
* Linux says **“RTNETLINK: File exists”**,
    
* and network links get messed up.
    

👉 Run it **once** to build the network,  
then use `start_`[`network.sh`](http://network.sh) to restart and `stop_`[`network.sh`](http://network.sh) to stop.

## 🌐 5. start\_network.sh

```bash
#!/bin/bash
# ============================================
# Start existing tinet containers (if any)
# or recreate if they don't exist
# ============================================

echo "🚀 Starting network containers..."

EXIST=$(docker ps -a --format '{{.Names}}' | grep -E '^(R1|R2|C1|C2|C3|C4)$')

if [ -z "$EXIST" ]; then
  echo "⚠️  Containers not found. Running setup..."
  sudo bash ./up_with_ip.sh
else
  docker start R1 R2 C1 C2 C3 C4 >/dev/null 2>&1
  echo "✅ Containers started."
fi

# recreate /var/run/netns links (important after reboot)
for node in R1 R2 C1 C2 C3 C4; do
  PID=$(docker inspect $node --format '{{.State.Pid}}' 2>/dev/null)
  if [ -n "$PID" ]; then
    mkdir -p /var/run/netns
    ln -sf /proc/$PID/ns/net /var/run/netns/$node
  fi
done

echo " Network namespaces linked and ready."
```

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1759576023566/4a2da2b8-6e58-49f6-8d58-599cb6a6a7c4.png align="center")

## 🌐 6. stop\_network.sh

```bash
#!/bin/bash
# ============================================
# Stop tinet containers safely
# ============================================
echo " Stopping containers..."
docker stop R1 R2 C1 C2 C3 C4 >/dev/null 2>&1
echo " All containers stopped."
```

### ✅ **Correct Usage Flow**

| Situation | Command | Description |
| --- | --- | --- |
| **Initial setup (run once)** | `sudo ./up_with_`[`ip.sh`](http://ip.sh) | Creates all containers, IP addresses, and links |
| **Daily use (reuse existing setup)** | `sudo ./start_`[`network.sh`](http://network.sh) | Restarts previously stopped containers |
| **When finishing practice** | `sudo ./stop_`[`network.sh`](http://network.sh) | Stops containers without deleting them |